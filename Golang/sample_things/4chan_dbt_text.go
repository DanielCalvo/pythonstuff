package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"strconv"
	"strings"
	"time"
)

//Generated by https://mholt.github.io/json-to-go/ - Thanks Matt!

type catalog []struct {
	Page    int `json:"page"`
	Threads []struct {
		No            int    `json:"no"`
		Sticky        int    `json:"sticky,omitempty"`
		Closed        int    `json:"closed,omitempty"`
		Now           string `json:"now"`
		Name          string `json:"name"`
		Sub           string `json:"sub,omitempty"`
		Com           string `json:"com,omitempty"`
		Filename      string `json:"filename"`
		Ext           string `json:"ext"`
		W             int    `json:"w"`
		H             int    `json:"h"`
		TnW           int    `json:"tn_w"`
		TnH           int    `json:"tn_h"`
		Tim           int64  `json:"tim"`
		Time          int    `json:"time"`
		Md5           string `json:"md5"`
		Fsize         int    `json:"fsize"`
		Resto         int    `json:"resto"`
		SemanticURL   string `json:"semantic_url"`
		Replies       int    `json:"replies"`
		Images        int    `json:"images"`
		OmittedPosts  int    `json:"omitted_posts,omitempty"`
		OmittedImages int    `json:"omitted_images,omitempty"`
		LastReplies   []struct {
			No    int    `json:"no"`
			Now   string `json:"now"`
			Name  string `json:"name"`
			Com   string `json:"com"`
			Time  int    `json:"time"`
			Resto int    `json:"resto"`
		} `json:"last_replies"`
		LastModified int `json:"last_modified"`
		Bumplimit    int `json:"bumplimit,omitempty"`
		Imagelimit   int `json:"imagelimit,omitempty"`
	} `json:"threads"`
}

func main() {

	dbt_thread_number := get_dbt_thread()

	if dbt_thread_number == "" {
		log.Fatal("No dbt thread could be found. Exiting")
	}

	dbt_thread_url := "http://a.4cdn.org/o/thread/" + string(dbt_thread_number) + ".json"
	fmt.Println("Thread URL is:", dbt_thread_url)

}

func get_dbt_thread() string {

	//I should create a function for this as well!
	catalog_url := "http://a.4cdn.org/o/catalog.json"
	catalogClient := http.Client{Timeout: time.Second * 2}
	catalog_req, reqErr := http.NewRequest(http.MethodGet, catalog_url, nil)

	if reqErr != nil {
		log.Fatal(reqErr)
	}

	res, resErr := catalogClient.Do(catalog_req)

	if resErr != nil {
		log.Fatal(resErr)
	}

	body, readErr := ioutil.ReadAll(res.Body)
	if readErr != nil {
		log.Fatal(readErr)
	}

	catalog1 := catalog{}

	unmarshalErr := json.Unmarshal(body, &catalog1)
	if unmarshalErr != nil {
		log.Fatal(unmarshalErr)
	}

	for _, page := range catalog1 {
		for _, thread := range page.Threads {
			if strings.Contains(thread.Sub, "dbt") || strings.Contains(thread.Com, "dbt") {
				return strconv.Itoa(thread.No)
			}
		}
	}
	return ""
}
