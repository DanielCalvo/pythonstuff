
TODO IDEAS:


Some more usefuf information may be available here:
https://docs.docker.com/v17.09/engine/userguide/networking/default_network/custom-docker0/
https://docs.docker.com/v17.09/engine/userguide/networking/default_network/container-communication/#communicating-to-the-outside-world



- Create container image through salt
- Set up macvlan networking
- Set up 3 instances: A web server with the logs on a volume, something to do queries to the webserver, and a logging container to do something with those logs on the volume
- Set up your own registry and describe how to do it!

Creating and testing your own symfony demo container:

mkdir symfonydemo
cd symfonydemo
vim Dockerfile

Put this in the Dockerfile as you know these are necessary:

FROM debian:latest
RUN apt-get update && apt-get install curl php-symfony git -y
RUN curl -sS https://getcomposer.org/installer | php && mv composer.phar /usr/local/bin/composer

To further investigate how to set up symfoiny demo, create an image from your Dockerfile and run bash into it so you can find out the next steps to have the image running:

#In the same directory as the Dockerfile:
docker image build . --tag symfonydemo:v1

#Launch image and run bash:
docker run -i -t symfonydemo:v1 /bin/bash

Remember to rebuild the image every time you change the Dockerfile!

When you're done with everything, how do you launch the instance again?

docker exec -it sad_hugle bash

docker exec --user root -it sad_hugle bash

docker run -d symfonydemo:v1

---- KUBECTL ----

https://kubernetes.io/docs/tutorials/kubernetes-basics/

---- KUBECTL ----

---- DOCKER COMPOSE ----

https://docs.docker.com/compose/wordpress/

---- DOCKER COMPOSE ----

---- MYSQL MULTIMASTER ----

https://www.percona.com/blog/2016/03/30/docker-mysql-replication-101/
https://hub.docker.com/r/mysql/mysql-cluster/

---- MYSQL MULTIMASTER ----




--- MACVLAN ---


#This doesn't work:
docker run --rm -itd --network pub_net --name macvlan-deb debian:latest bash
docker exec macvlan-deb ip addr show eth0
docker exec --user root -it macvlan-deb bash


#Inside a docker machine, also doesn't work either
docker network create -d macvlan --subnet=192.168.1.0/24 --gateway=192.168.1.1 -o parent=enp0s8 pub_net
docker run --rm -itd --network pub_net --name macvlan-deb debian:latest bash
docker exec --user root -it macvlan-deb bash


#Trying a L2 bridge:

docker network create -d ipvlan --subnet=192.168.1.0/24 --gateway=192.168.1.1 -o ipvlan_mode=l2 ipvlan210 #Fails

--- MACVLAN ---


--- DOCKER VOLUMES AND NETWORKS ---


docker image pull redis:alpine
docker image pull russmckendrick/moby-counter
docker network create moby-counter

docker network inspect moby-counter #Hmmm...

docker container run -d --name redis --network moby-counter redis:alpine
docker container run -d --name moby-counter --network moby-counter -p 8080:80 russmckendrick/moby-counter

docker container ls

Interesting, the redis images exposes the redit port by default (erm, that makes sense)

Application should be available on localhost:8080

But how did the app know the address of the redis container?
If attempt to ping the redis application from the container, it works:

docker container exec moby-counter ping -c 3 redis

Does it have an entry for redis in the hosts file? :o
docker container exec moby-counter cat /etc/hosts

It doesnt. Very intriguing. What nameserver is being used?
docker container exec moby-counter cat /etc/resolv.conf

127.0.0.11, hmmm, I wonder if that's resolving our redis name?
docker container exec moby-counter nslookup redis 127.0.0.11

It is!

At this point the book creates another network and launches the applications gain:

docker network create moby-counter2
docker run -itd --name moby-counter2 --network moby-counter2 -p 9090:80 russmckendrick/moby-counter

We attempt to ping redis again and it doesn't work:
docker container exec moby-counter2 ping -c 3 redis
ping: bad address 'redis'

Another redit instance named redis2 is launched:
docker container run -d --name redis2 --network moby-counter2 --network-alias redis redis:alpine

Now the previous ping works:
docker container exec moby-counter2 ping -c 3 redis

PING redis (172.19.0.3): 56 data bytes
64 bytes from 172.19.0.3: seq=0 ttl=64 time=0.090 ms

Docker has some sort of internal, network-level name resolution that resolves names based on image names. You can see the names based on the instances that are running on a given network:

docker network inspect moby-counter2

To end this part of the book, stop and prune everything:

docker container stop moby-counter2 redis2
docker container prune
docker network prune

--- DOCKER VOLUMES AND NETWORKS ---




